<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>第二章 信息的表示与处理</title>
	</head>
	<body>
		<h2>无符号数的编码</h2>
		<div>无符号数的编码就是其二进制</div>
		<h2>补码编码</h2>
		<div>
		最常见的有符号数的计算机表示方式就是补码形式。在这个定义中，将字的最高有效位解释为负权(即符号位)。符号位被设置为1时，表示值为负，而当设置为0时，值为非负。<br>
		有几点值得注意:<br>
		第一，补码的范围是不对称的:|TMin|=|TMax|+1，也就是说，TMin没有与之对应的正数。之所以会有这样的不对称性，是因为一半的位模式(符号位设置为1的数)表示负数，
		而另一半(符号位设置为0的数)表示非负数。因为0是非负数，也就意味着能表示的整数比负数少一个。<br>
		第二，最大的无符号数值刚好比补码的最大值的两倍大一点:UMax[w]= 2TMax[w]+1, 补码表示中所有表示负数的位模式在无符号表示中都变成了正数。<br>
		关于整数数据类型的取值范围和表示，Java标准是非常明确的。它要求采用补码表示。在Java中，单字节数据类型称为byte，而不是char。这些非常具体的要求都是为了保证无论在什么机器上运行，Java程序都能表现地完全一样。<br />
		</div>
		<h2>有符号数和无符号数之间的转换</h2>
		<div>
		C语言允许无符号数和有符号数之间的转换。虽然C标准没有精确规定应如何进行这种转换，但大多数系统遵循的原则是底层的位表示保持不变。因此，在一台采用补码的机器上，
		当从无符号数转换为有符号数时，效果就是应用函数U2T[w]，而从有符号数转换为无符号数时，就是应用函数T2U[w].，其中w表示数据类型的位数。<br>
		由于C语言对同时包含有符号和无符号数表达式的这种处理方式，出现了一些奇特的行为。当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言
		会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。就像我们将要看到的，这种方法对于标准的算术运算来说并无多大差异，但是对于
		像这样的关系运算符来说，它会导致非直观的结果。
		</div>
		<h2>扩展一个数字的位表示</h2>
		<div>
		一个常见的运算是在不同字长的整数之间转换，同时又保持数值不变。当然，当目标数据类型太小以至于不能表示想要的值时，这根本就是不可能的。然而，从一个较小的数据类型转换到一个较大的类型，应该总是可能的。<br>
		要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加0.这种运算被称为零扩展(zero extension)<br>
		要将一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展(sign exten-sion)，在表示中添加最高有效位的值<br>
		</div>
		<h2>截断数字</h2>
		<div>
		假设我们不用额外的位来扩展一个数值，而是减少表示一个数字的位数。当将一个w位的数x={x[w-1],x[w-2],...,x[1],x[o]}截断为一个k位数字时，我们会丢弃高w-k位，得到一个位向量x= {x[k-1],x[k-2],...,x[1],x[o]}。截断一个数字可能会改变它的值溢出的一种形式。对于一个无符号数，我们可以很容易得出其数值结果。
		</div>
		<h2>浮点数</h2>
		<div>
		...
		</div>
		<h2>小结</h2>
		<div>
		计算机将信息编码为位(比特)，通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。<br>
		c语言的设计可以包容多种不同字长和数字编码的实现。64位字长的机器逐渐普及，并正在取代32位机器。由于64位机器也可以运行为32位机器编译的程序，我们的重点就放在区分32位和64位程序，而不是机器本身。64位程序的优势是可以突破32位程序具有的4GB地址限制。<br>
		c语言的设计可以包容多种不同字长和数字编码的实现。64位字长的机器逐渐普及，并正在取代32位机器。由于64位机器也可以运行为32位机器编译的程序，我们的重点就放在区分32位和64位程序，而不是机器本身。64位程序的优势是可以突破32位程序具有的4GB地址限制。。<br>
		大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码。在位级上理解这些编码，并且理解算术运算的数学特性，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。。<br>
		在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个w位的值，这种行为是由函数T2U[w]]和U2T[w]来描述的。C语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。。<br>
		由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于0.0，从而转换成零时，也会下溢出<br>
		和大多数其他程序语言一样，C语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属性。例如，由于溢出，表达式x*x能够得出负数。但是，无符号数和补码的运算都
		满足整数运算的许多其他属性，包括结合律、交换律和分配律。这就允许编译器做很多的优化。例如，用(x<<3)-x取代表达式7*x时，我们就利用了结合律、交换律和分配律的属性，还利用了移位和乘以2的幂之间的关系。。<br>
		我们已经看到了几种使用位级运算和算术运算组合的聪明方法。例如，使用补码运算，~x+1等价于-x。另外一个例子，假设我们想要一个形如[0,…，0，1,…，1]的位模式，由w-k个0后面紧跟着k个1组成。这些位模式有助于掩码运算。这种模式能够通过C表达式(1<<k)-1生成，利用的是这样一个属性，即我们想要的位模式的数值为2<k>一1。例如，表达式(1<<8)-1将产生位模式0xFF.。<br>
		浮点表示通过将数字编码为.x*2<y>的形式来近似地表示实数。最常见的浮点表示方式是由IEEE标准754定义的。它提供了几种不同的精度，最常见的是单精度(32位)和双精度(64位)。
		IEEE浮点也能够表示特殊值正负无穷和NaN。。<br>
		必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且并不遵守普遍的算术属性，比如结合性。。<br>
		</div>
	</body>
</html>
