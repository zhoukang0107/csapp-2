<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>第二章 信息的表示与处理</title>
	</head>
	<body>
		<h2>2.1 信息的存储</h2>
		<div>
			 大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)。内存的每个字节都由一个唯一的数字来标识，称为它
			 的地址(address)，所有可能地址的集合就称为虚拟地址空间(virtual address space),顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操
			 作系统软件结合起来，为程序提供一个看上去统一的字节数组。<br>
			C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象
			可以简单地视为一个字节块，而程序本身就是一个字节序列。
			为了方便表示8个位组成的字节，我们使用十六进制来表示位模式；<br >
			<h3>字数据大小</h3>
			<div>
				每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为二位的机器而言，虚拟地
			址的范围为0~2^w-1,程序最多访问2^w个字节。<br >
			    32位字长限制虚拟地址空间为4千兆字节(写作4GB)。扩展到64位字长使得虚拟地址空间为16EB，大约是1.84 X 10^19字节。<br >
			    我们将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。<br >
			</div>
			<h3>寻址和字节顺序</h3>
			<div>
				对于跨越多字节的程序对象，我们必须建立两个规则:这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。<br />
				例如，假设一个类型为int的变量x的地址为0x100，也就是说，地址表达式&x的值为。x100。那么，(假设数据类型int为32位表示)x的4个字节将被存储在内存的0x100, 0x101, 0x102和0x103位置。<br />
				排列表示一个对象的字节有两个通用的规则。考虑一个w位的整数，其位表示为[x(w-1),x(w-2),...,x(1),x(0)]，其中x(w-1)是最高有效位，而x(0),是最低有效位。假设w是8的倍数，这些位就能被分组成为字节，其中最高有效字节包含
				位[x(w-1),x(w-2),…，x(w-8)]，而最低有效字节包含位[x(7),x(6),…，x(0)]，其他字节包含中间的位。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节
				的顺序存储。前一种规则—最低有效字节在最前面的方式，称为小端法((little endian).后一种规则—最高有效字节在最前面的方式，称为大端法(big endian).<br />

			    假设变量x的类型为int,位于地址x100处,它的十六进制值为。x01234567。地址范围Ox100~Ox103的字节顺序依赖于机器的类型(注意，在字0x01234567中，高位字节的十六进制值为x01，而低位字节值为Ox67):<br />
				<pre>
				大端法
			    0x100 0x101 0x102 0x103
			      01    23    45    67
			    小端法
			    0x100 0x101 0x102 0x103
			      67    45    23    01
				</pre>
				<br />
	
			    大多数Intel兼容机都只用小端模式。IBM和Oracle的大多数机器则是按大端模式操作。注意我们说的是“大多数”。这些规则并没有严格按照企业界限来划分。许多比较新的微处理器是双端法(bi-endian),也就是说可以把它们配置成作为大端
				或者小端的机器运行。然而，实际情况是:一旦选择了特定操作系统，那么字节顺序也就固定下来。比如，用于许多移动电话的ARM微处理器，其硬件可以按小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统—Android和IOS却只
				能运行于小端模式。<br />
			</div>
			
			<h3>
				逻辑右移和算术右移
			</h3>
			<div>
				逻辑右移:在左端补k个0，得到的结果是[0,…，0,x(w-1),x(w-2),…,x(k)]。<br />
				算术右移是在左端补k个最高有效位的值，得到的结果是[x(w-1),…,x(w-1),x(w-1),x(w-2),…,x(k)]。这种做法看上去可能有点奇特，但是我们会发现它对有符号整数数据的运算非常有用。<br />
				C语言标准并没有明确定义对于【有符号数】应该使用哪种类型的右移—算术右移或者逻辑右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器/机器组合都对
				有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。另一方面，对于【无符号数】，右移必须是逻辑的。<br />
				注意：与C相比，Java对于如何进行右移有明确的定义。表达是x>>k会将x算术右移k个位置，而x>>>k会对x做逻辑右移。<br />
			</div>
		</div>
		<h2></h2>
	</body>
</html>
