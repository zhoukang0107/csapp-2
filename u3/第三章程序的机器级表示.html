<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>第三章程序的机器级表示</title>
	</head>
	<body>
		<div>
			<h2>数据格式</h2>
			<div>
				由于是从16位体系结构扩展成32位的，Intel用术语“字(word)”表示16位数据类32位数为“双字(double words)"，称64位数为“四字(quad words)"。
				大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种:movb(传送字节)、movew(传送字)、movl(传送双字)和movq(传送四字)。后缀"l"用来表示双字，
				因为32位数被看成是“长字(longword)"。注意，汇编代码也使用后缀`l’来表示4字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。
			</div>
			<h2>
				访问信息
			</h2>
			<div>
				一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针，它们的名字都以%r开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。每个寄存器都有
				特殊的用途，它们的名字就反映了这些不同的用途。指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，而64位操
				作可以访问整个寄存器。<br />
			    很多指令，复制和生成1字节、2字节、4字节和8字节值。当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则:生成1字节和2字节数字的指令会保持剩下的字节不变;生成4字节数
				字的指令会把高位4个字节置为0。后面这条规则是作为从IA32到x86-64的扩展的一部分而采用的。
				<br />
				<img src="./res/1.png" />
				<br />
				<h3>操作数指示符</h3>
				<div>
					大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64支持多种操作数格式。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存
					中。因此，各种不同的操作数的可能性被分为三种类型。<br />
					第一种类型是立即数：<br />
					用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是‘$’后面跟一个用标准C表示法表示的整数，比如，$-577或$$Ox1F。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。<br />
					第二种类型是寄存器:<br />
					它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应于8位、16位、32位或64位。我们用符号r(a)来表示任意寄存器a，用引用R[r(a)]来表示它的值，这是将寄存器集合
					看成一个数组R，用寄存器标识符作为索引。<br />
					第三类操作数是内存引用:<br />
					它会根据计算出来的地址(通常称为有效地址)访问某个内存位置。因为将内存看成一个很大的字节数组，我们用符号M(b)[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。为了简便，我们通常省去下标b.<br />
					Imm(rb,ri,s)表示的是最常用的形式。这样的引用有四个组成部分:一个立即数偏移Imm，一个基址寄存器rb，一个变址寄存器ri;和一个比例因子s，这里s必须是1, 2, 4或者8。基址和变址寄存器都必须是64位寄存器。有效地址被计算
					为Imm+R[rb]+R[ri]*s.引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些部分。
					<img src="./res/2.png" /><br />
				</div>
				<h3>数据传送指令</h3>
				<div>
					最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。MOV类:<br />
					    这些指令把数据从源位置复制到目的位置，不做任何变化。MOV类由四条指令组成:movb, moves, movl和movq。这些指令都执行同样的操作;主要区别在于它们操作的数据大小
					不同:分别是1,2,4和8字节。<br />		
					源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者是一个内存地址。<br />
					常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。<br />
					<br>
					MOVZ类指令：<br>
					把目的中剩余的字节填充为0；这些指令以寄存器或内存地址作为源，以寄存器作为目的<br />
					MOVS类指令：<br>
					通过符号扩展来填充，把源操作的最高位进行复制,MOVS指令以寄存器或内存地址作为源，以寄存器作为目的。cltq指令没有操作数:它总是以寄存器%eax作为源，%rax作为符号扩展结果的目的。它的效果与指令
					movslq %eax,%rax完全一致，不过编码更紧凑。
				</div>
				
				<h3>
					压入和弹出栈数据
				</h3>
				<div>
					<img src="./res/3.png" />
					<br>
					pushq指令的功能是把数据压人到栈上，而popq指令是弹出数据。这些指令都只有一个操作数—压入的数据源和弹出的数据目的。
				</div>
			</div>
			
			<h2>算术和逻辑操作</h2>
			<div>
				<img src="./res/3.png" />
				<br />
				大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种(只有leaq没有其他大小的变种)。例如，指令类ADD由四条加法指令组成:addb, addw, addl和addq，分别是字节加法、字加法、双字加法和四字加法。事实上，
				给出的每个指令类都有对这四种不同大小数据的指令。这些操作被分为四组:加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，而一元操作有一个操作数。这些操作数的描述方法与MOV一样;
				<h3>加载有效地址</h3>
				<div>
					加载有效地址(load effective address)指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看
					上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写人到目的操作数。
				</div>
				<h3>一元和二元操作</h3>
				<div>
					第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。<br />
					第三组是二元操作，其中，第二个操作数既是源又是目的。要注意，源操作数是第一个，目的操作数是第二个，对于不可交换操作来说，这看上去很奇特。第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器
					或是内存位置。注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。
				</div>
				
				<h3>移位操作</h3>
				<div>
					最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器%c1中。(这些指令很特别，因为只允许以这个特定的寄存器作为操作数)原则上来说，
					1个字节的移位量使得移位量的编码范围可以达到一个字节大小，即255。x86-64中，移位操作对w位长的数据值进行操作，移位量是由%c1寄存器的低m位决定的，这里2的m次方等于w。高位会被忽略。所以，例如当寄存器%Cl的十六进
					制值为xFF时，指令salb会移7位，saltw会移15位，sall会移31位，而salq会移63位。<br>
					左移指令有两个名字:SAL和SHL。两者的效果是一样的，都是将右边填上0。右移指令不同，SAR执行算术移位(填上符号位)，而SHR执行逻辑移位(填上0)。移位操作的目的操作数可以是一个寄存器或是一个内存位置。用>>A(算术)和
					>>L(逻辑)来表示这两种不同的右移运算。
				</div>
				<h3>特殊的算术操作</h3>
				<div>
					两个64位有符号或无符号整数相乘得到的乘积需要128位来表示。x86-64指令集对128位(16字节)数的操作提供有限的支持。延续字((2字节)、双字((4字节)和四字(8字节)的命名惯例，Intel把16字节的数称为八字(oct word)。
					下图是支持产生两个64位数字的全128位乘积以及整数除法的指令。
					<img src="./res/4.png" />
				</div>
			</div>
			
			<h2>控制</h2>
			<div>
				机器代码提供两种基本的低级机制来实现有条件的行为:测试数据值，然后根据测试的结果来改变控制流或者数据流。
				<h3>条件码</h3>
				<div>
					除了整数寄存器，CPU还维护着一组单个位的条件码(condition code)寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有:<br />
					CF:进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。<br />
					ZF:零标志。最近的操作得出的结果为。<br />
					SF:符号标志。最近的操作得到的结果为负数。<br />
					OF:溢出标志。最近的操作导致一个补码溢出—正溢出或负溢出。<br /
				</div>
				<h3>访问条件码</h3>
				<div>
					条件码通常不会直接读取，常用的使用方法有三种:<br />
					    1)可以根据条件码的某种组合，将一个字节设置为0或者1；<br />
					    2)可以条件跳转到程序的某个其他的部分；<br />
					    3)可以有条件地传送数据。<br />
					    对于第一种情况，指令根据条件码的某种组合，将一个字节设置为0或者1。我们将这一整类指令称为SET指令;它们之间的区别就在于它们考虑的条件码的组合是什么，<br />
					这些指令名字的不同后缀指明了它们所考虑的条件码的组合。这些指令的后缀表示不同的条件而不是操作数大小。例如，指令setl和setb表示"小于时设置(set less)"和"低于时设置(set below)"，而不是"设置长字(set
					long word)"和"设置字节(set byte)".<br />
				</div>
				
				<h3>跳转指令</h3>
				<div>
					跳转(jump)指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label)指明。 mp指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的;也可以是间接跳转，
					即跳转目标是从寄存器或内存位置中读出的。汇编语言中，直接跳转是给出一个标号作为跳转目标的。<br />
					<img src="./res/6.png" />
					<br />
					图中所示的其他跳转指令都是有条件的—它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字和跳转条件与SET指令的名字和设置条件是相匹配的。同SET指令一样，一些底层的机器指令有多个名字。条件跳转只能是直接跳转。
				</div>
				
				<h3>跳转指令的编码</h3>
				<div>
					在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是PC相对的(PC-relative)。也就是，它们会将目标指令的地址与紧跟在跳转指令后面
					那条指令的地址之间的差作为编码。这些地址偏移量可以编码为1, 2或4个字节。第二种编码方法是给出“绝对”地址，用4个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。
				</div>
				
				<h3>用条件控制来实现条件分支</h3>
				<div>
					将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。
				</div>
				<h3>用条件传送来实现条件分支</h3>
				<div>
					。。。。
				</div>
			</div>
			
			<h2>过程（函数 / 方法调用过程）</h2>
			<div>
				要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程P调用过程Q，Q执行后返回到P。这些动作包括下面一个或多个机制:<br />
				传递控制:在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。<br />
				传递数据:P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。<br />
				分配和释放内存:在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。<br />
				<h3>运行时栈</h3>
				<div>
					C语言过程调用机制的一个关键特性(大多数其他语言也是如此)在于使用了栈数据结构提供的后进先出的内存管理原则。在过程P调用过程Q的例子中，可以看到当Q在执行时，
					P以及所有在向上追溯到P的调用链中的过程，都是暂时被挂起的。当Q运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。另一方面，当Q返回时，任何
					它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当P调用Q时，
					控制和数据信息添加到栈尾。当P返回时，这些信息会释放掉。<br />
					    x86-64的栈向低地址方向增长，而栈指针%rsp指向栈顶元素。可以用pushq和popq指令将数据存人栈中或是从栈中取出。将栈指针减小一个适当的量可以为没有指定初始值的
					数据在栈上分配空间。类似地，可以通过增加栈指针来释放空间。<br />
					    当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧(stack fram)。当前正在执行的过程的帧总是在栈顶。当过程P
					调用过程Q时，会把返回地址压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关的状态。Q的代码会扩
					展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数过程的栈帧都是定长的，在过程的开始
					就分配好了。但是有些过程需要变长的帧。通过寄存器，过程P可以传递最多6个整数值(也就是指针和整数)，但是如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储好
					这些参数。<br />
					    为了提高空间和时间效率，x86-64过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。实际上，许多函数甚至
					根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数(有时称之为叶子过程，此时把过程调用看做树结构)时，就可以这样处理。例如，到
					目前为止我们仔细审视过的所有函数都不需要栈帧。<br />
				</div>
				
				<h3>转移控制</h3>
				<div>
					将控制从函数P转移到函数Q只需要简单地把程序计数器(PC)设置为Q的代码的起始位置。不过，当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。在
					x86-64机器中，这个信息是用指令call Q调用过程Q来记录的。该指令会把地址A压人栈中，并将PC设置为Q的起始地址。压人的地址A被称为返回地址，是紧跟在call指令后面的那
					条指令的地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A.<br />
					    call指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，调用可以是直接的，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的目标
					是*后面跟一个操作数指示符.<br />
				</div>
				
				<h3>数据传送</h3>
				<div>
					当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。x86-64中，
					大部分过程间的数据传送是通过寄存器实现的。<br />
					    x86-64中，可以通过寄存器最多传递6个整型(例如整数和指针)参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，会
					根据参数在参数列表中的顺序为它们分配寄存器。可以通过64位寄存器适当的部分访问小于64位的参数。例如，如果第一个参数是32位的，那么可以用%edi来访问它<br />。
					    如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。假设过程P调用过程Q，有n个整型参数，且n>6。那么P的代码分配的栈帧必须要能假设过程容纳7到n号参
					数的存储空间。要把参数1~6复制到对应的寄存器，把参数7~n放到栈上，而参数7位于栈顶。通过栈传递参数时，所有的数据大小都向8的倍数对齐。参数到位以后，
					程序就可以执行call指令将控制转移到过程Q了。过程Q可以通过寄存器访问参数，有必要的话也可以通过栈访问。<br />
				</div>
				
				<h3>栈上的局部存储</h3>
				<div>
					到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不过有些时候，局部数据必须存放在内存中，常见的情况包括:<br />
					    .寄存器不足够存放所有的本地数据;<br />
					    .对一个局部变量使用地址运算符‘&’，因此必须能够为它产生一个地址;<br />
					    .某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到;<br />
				</div>
				
				<h3>寄存器中的局部存储空间</h3>
				<div>
					寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程(调用者)调用另一个过程(被调用者)时，被调用者不会覆盖调
					用者稍后会使用的寄存器值。为此，x86-64采用了一组统一的寄存器使用惯例，所有的过程(包括程序库)都必须遵循。<br />
					    根据惯例，寄存器%rbx,%rbp和%r12~0r15被划分为被调用者保存寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样
					的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压人栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标
					号为“保存的寄存器”的一部分。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中(当然，要先把之前的值保存到栈上)，调用Q，然后继续使用寄存器中的值，不用
					担心值被破坏。<br />
				</div>
				...
			</div>
		</div>
	</body>
</html>
